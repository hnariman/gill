import { useQuery } from "@tanstack/react-query";
import { Account, Address, createSolanaClient, FetchAccountConfig, getProgramDerivedAddress, SolanaClient } from "gill";
import { getAssociatedTokenAccountAddress } from "gill/programs";

import { GILL_HOOK_CLIENT_KEY } from "../const.js";

// TODO:(hariman) import Seed type - ordered Array of Uint8Array or Uint16Array, always?
type Seeds = Uint8Array;

type GetPDAProps = {
  /**
   * An optional function to fetch & decode Solana account data
   * typically generated by Codama
   * if not provided only PDA address is returned
   * @param rpc - RPC client instance
   * @param address - programAddress
   * @param config - optional config for fetch
   * @returns PDA address or PDA address & account data
   * @async
   */
  fetcher?: (
    rpc: SolanaClient["rpc"],
    address: Address<string>,
    config?: FetchAccountConfig,
  ) => Promise<Account<Uint8Array | object, string>>;
  /** Solana address of the program, which owns PDA */
  programAddress: Address;
  /** An ordered array of seeds used to derive the PDA from the program address.
   * @see https://solanacookbook.com/core-concepts/pdas.html#seeds
   */
  seeds: Seeds[];
};

/** Always returns PDA address & Optionally parsed PDA account data */
type GetPDAReturn = {
  /** PDA address */
  address: Address;
  /** PDA account data*/
  data?: Uint8Array | object;
};

/** Find Program Derived Address (PDA) and Optionally parse it's account data */
async function getPDA({ seeds, programAddress, fetcher }: GetPDAProps): Promise<GetPDAReturn> {
  const [address] = await getProgramDerivedAddress({ programAddress, seeds });
  // TODO:(hnariman) reuse instance from higher leve context?
  const { rpc } = createSolanaClient({ urlOrMoniker: "devnet" });

  if (!fetcher) {
    return { address };
  }

  const { data } = await fetcher(rpc, address);

  return {
    address,
    data,
  };
}

// type ATAParserProps = {
//   mintAddress: Address;
//   programAddress: Address;
//   tokenProgram?: Address;
// };

// /** Find Associated Token Account (ATA) */
// // TODO:(hnariman) remove if no extra logic required before submitting PR for review
// async function getATA({ mintAddress, owner, tokenProgram }: ATAParserProps): Promise<string> {
//   return await getAssociatedTokenAccountAddress(mintAddress, owner, tokenProgram);
// }

/** type safe account types */
const ACCOUNT_TYPE = {
  // ATA: "ATA",
  MINT: "MINT",
  PDA: "PDA",
} as const;

/** abstract to extend */
type TBaseAccount = { title: string };

type TMintAccount = TBaseAccount & {
  mintAddress: Address;
  owner: Address;
  tokenProgram?: Address;
  type: typeof ACCOUNT_TYPE.MINT;
};

type TPdaAccount = TBaseAccount & {
  programAddress: Address;
  seeds: Seeds[];
  tokenProgram?: Address;
  type: typeof ACCOUNT_TYPE.PDA;
};

// type TAtaAccount = TBaseAccount & {
//   seeds: Seeds[];
//   type: typeof ACCOUNT_TYPE.ATA;
// };

type TPdaWithFetcherAccount = TPdaAccount & {
  fetcher: GetPDAProps["fetcher"];
};

// type TProgramAccount = TAtaAccount | TMintAccount | TPdaAccount | TPdaWithFetcherAccount;
type TProgramAccount = TMintAccount | TPdaAccount | TPdaWithFetcherAccount;

type AccountType = (typeof ACCOUNT_TYPE)[keyof typeof ACCOUNT_TYPE];

// TODO: (hariman) add strict handler function types
// eslint-disable-next-line @typescript-eslint/no-unsafe-function-type
const accountHandlers: Record<AccountType, Function> = {
  [ACCOUNT_TYPE.PDA]: getPDA,
  // [ACCOUNT_TYPE.ATA]: getATA,
  [ACCOUNT_TYPE.MINT]: getPDA,
};

async function parseSingleAccount(account: TProgramAccount) {
  const handler = accountHandlers[account.type];
  //TODO: remove when strict types for handlers implemented, must become infallible
  if (!handler) {
    throw new Error("incorrect accont type provided");
  }
  return await handler(account);
  // return accountHandlers[account.type](account);
}

export async function parseAccounts(accounts: Array<TProgramAccount>) {
  const parsed = await Promise.allSettled(accounts.map(parseSingleAccount));
  parsed.filter((i) => i.status === "fulfilled");
  return parsed;

  //TODO:(hnariman) consider removing parse single account fn if it's not useful alone anywhere else
  // return await Promise
  // .allSettled(accounts.map(a => accountHandlers[a.type](a)))
  // .filter(res => res.status === "fulfilled");
}

/** simplified version without extra TS shenanigans */
export async function simpleAccountHandler(accounts: Array<TProgramAccount>) {
  return await Promise.allSettled(
    accounts.map((ac) => {
      switch (ac.type) {
        // case "ATA":
        //   return async () => await getAssociatedTokenAccountAddress(ac.mintAddress, ac.owner, ac.tokenProgram);
        case "MINT":
          return async () => await getAssociatedTokenAccountAddress(ac.mintAddress, ac.owner, ac.tokenProgram);
        case "PDA":
          return getPDA(ac);
        default:
          return Promise.reject(new Error("Unsupported account type"));
      }
    }),
  );
}

interface IUseFetchAccountsProps {
  accounts: Array<TProgramAccount>;
}
export function useFetchAccounts({ accounts }: IUseFetchAccountsProps) {
  return useQuery({
    queryFn: () => {
      return simpleAccountHandler(accounts);
    },
    queryKey: [GILL_HOOK_CLIENT_KEY, "fetchAccounts"],
  });
}
